/** \file iterative_algorithm.hpp
    \brief Содержит абстрактный шаблонный класс "итеративный алгоритм" -
	алгоритм, который на каждом шаге вычисляет некоторый кватернион, на который
	надо умножить ответ в предыдущий момент времени, чтобы получить ответ в
	текущий момент времени.
*/

#pragma once
#ifndef ALGORITHMS_ITERATIVE_ALGORITHM_H
#define ALGORITHMS_ITERATIVE_ALGORITHM_H



#include <vector>
#include "algorithm.hpp"



/** Класс "итеративный алгоритм".
 *
 * Этот класс является абстрактным шаблонным классом, описывающим интерфейс
 * любого итеративного алгоритма.
 *
 * Итеративный алгоритм - это алгоритм, который на каждом шаге вычисляет
 * некоторый (би)кватернион, на который надо умножить ответ в предыдущий момент
 * времени, чтобы получить ответ в текущий момент времени.
 *
 * Фактически, единственное, что должен определить класс-потомок - это способ
 * вычисления этого (би)кватерниона на текущем временном шаге. Для этого
 * классы- потомки должны реализовать метод get_local_solution_(), которому
 * передаются входные данные на текущем отрезке.
 *
 * Как правило, итеративные алгоритмы являются многошаговыми, т.е. для выдачи
 * одного очередного ответа используется сразу несколько входных значений.
 * "Шаговость" алгоритма (т.е. во сколько раз дискретность выдачи решения
 * меньше дискретности входных данных) классы-потомки могут задавать,
 * переопределяя метод get_algorithm_steps_count_().
 *
 * @tparam Q Выбранная алгебра (кватернионы/бикватернионы).
 * @tparam I Выбранный тип входных данных (классы-потомки, как правило, будут жёстко фиксировать этот тип в соответствии с их потребностями).
 */
template <typename Q, typename I>
class iterative_algorithm : public algorithm<Q,I> {

public:


	virtual ~iterative_algorithm() {
	}


protected:


	/** Возвращает "Шаговость" алгоритма.
	 *
	 * Шаговость - это то, во сколько раз дискретность выдачи решения
	 * меньше дискретности входных данных.
	 *
	 * По умолчанию равна единице, но классы-потомки могут переопределять это
	 * число.
	 */
	virtual int get_algorithm_steps_count_() {
		return 1;
	}


	/** Вычисляет решение на текущем временном отрезке.
	 *
	 * @param t Время, в которое требуется найти решение.
	 * @param gamma Входные данные на временном отрезке (это вектор, поскольку для многошаговых алгоритмов (см. get_algorithm_steps_count_()) передаётся соответствующее число входных данных: на нескольких подотрезках, в порядке их следования во времени).
	 */
	virtual Q get_local_solution_ (double t, const std::vector<I> & gamma) = 0;


private:


	/** Запускает алгоритм, возвращая полученные результаты работы.
	 *
	 * Этот метод полностью реализуется здесь, поэтому всё, что должны
	 * сделать потомки - это реализовать метод get_local_solution_(),
	 * вычисляющий решение на текущем временном отрезке.
	 */
	virtual typename algorithm<Q,I>::t_output_data_ptr execute() {
		typename algorithm<Q,I>::t_output_data_ptr result = this->init_output_data_();

		// выделяем память под входные данные на каждом текущем шаге
		int steps_count = this->get_algorithm_steps_count_();
		std::vector<I> gamma (steps_count);

		double step = this->step_;
		double delta_t = step / steps_count;

		for (size_t i=1; i<result->get_count(); ++i) {
			// вычисляем входные данные
			double t = result->ts[i];
			for (int j=0; j<steps_count; ++j) {
				double t1 = t - step + j * delta_t,
					t2 = t1 + delta_t;
				gamma[j] = this->input_data_->get_integrated (t1, t2);
			}

			// вычисляем решение на текущем временном отрезке
			Q q = this->get_local_solution_ (t, gamma);

			// вычисляем новый ответ
			(*result)[i] = (*result)[i-1] * q;
		}

		return result;
	}


}; // class iterative_algorithm



#endif // ifndef ALGORITHMS_ITERATIVE_ALGORITHM_H
